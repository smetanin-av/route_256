"""
Было замечено, что у разработчиков веб-сайтов очень частая ошибка - это случайное добавление одного лишнего тега в html
документ, который делает его некорректным. В рамках кампании по улучшению качества разрабатываемого программного
обеспечения, было принято решение о разработке программы для автоматического исправления подобного рода ошибок.
HTML-документ - это последовательность открывающих и закрывающих тегов. Открывающий тег - это последовательность
английских букв, обособленных треугольными скобками с двух сторон. Пример - <html> . Закрывающий тег - это тоже самое,
что и открывающих тег, но с дополнительным символом слеша после левой треугольной скобки. Пример - </html>.
Тег </X> является закрывающим тегом к <Y>, если X = Y (<Y> тогда - это открывающих тег для </X>). Все теги
регистронезависимые - это означает, что <HTML> и <html> - это один и тот же тег.
Каждый тег определяет элемент на странице. Элемент может быть пустой - это означает, что после открывающего тега
элемента, сразу стоит закрывающий. Элементы могут быть вложенными друг в друга. Это означает, что между открывающим и
закрывающим тегом находятся еще какое-то количество элементов.
При этом для корректного документа должны выполняться следующие свойства:
    Для одного открывающего тега может быть ровно один закрывающий тег.
    Для одного закрывающего тега может быть ровно один открывающий тег.
    Элементы могут быть только строго вложенными друг в друга - перехлест элементов запрещен (например <x><y></x></y>).

HTML-документ считается сломанным, если какое-то из этих свойств нарушается. Например, для данного тега не нашлось
открывающего/закрывающего тега или существует перехлест в тегах.
Для заданного HTML документа необходимо выяснить, является ли он сломанным или нет. Если документ является сломанным,
то нужно узнать, не был ли он сломан случайно разработчиком (разработчик мог случайно добавить один лишний тег).
То есть, если документ сломан, нужно проверить, можно ли его починить, удалив ровно один тег.

Ограничения
    Количество строк в документе h: 1 <= h <= 10^6.
    Количество букв внутри тега k: 1 <= k <= 100.

Формат входных данных
Первая строка содержит одно целое число x — количество наборов входных данных. После следуют x наборов данных.
Первая строка набора данных содержит одно число s - количество тегов в документе.
Следующие s строк — это последовательность тегов в документе. По одному тегу на каждой строке.

Формат выходных данных
Для каждого набора данных необходимо определить, насколько сломан документ.
Если документ корректен, необходимо вывести слово CORRECT.
Если документ некорректен, но при этом его можно починить, удалив ровно один тег — вывести ALMOST <TAG>.
Где <TAG> - это название тега, который необходимо удалить для починки. <TAG> необходимо выводить в верхнем регистре.
Если документ некорректен и при этом его нельзя починить указанным способом — вывести INCORRECT.
"""

from typing import List, Iterable


def input_int() -> int:
    line = input()
    return int(line)


def read_tag():
    return input().strip().upper()


def get_name(tag: str) -> str:
    return tag.strip('</>')


def is_closing(tag: str) -> bool:
    return tag.startswith('</')


def is_match(first: str, second: str) -> bool:
    return is_closing(first) != is_closing(second) and get_name(first) == get_name(second)


def check_tags(tags: Iterable[str], is_closings: bool) -> List[str]:
    stack = []
    errors = []
    for tag in tags:
        if is_closing(tag) == is_closings:
            stack.append(tag)
        elif stack and is_match(tag, stack[-1]):
            stack.pop()
        else:
            errors.append(tag)
        if len(errors) > 1:
            return errors
    return errors + stack


def solve():
    count_of_docs = input_int()
    for _ in range(count_of_docs):
        count_of_tags = input_int()
        all_tags = [read_tag() for _ in range(count_of_tags)]

        errors = check_tags(tags=all_tags, is_closings=False)
        if not errors:
            print('CORRECT')
        elif len(errors) == 1:
            print(f'ALMOST {errors[0]}')
        else:
            errors = check_tags(tags=reversed(all_tags), is_closings=True)
            if len(errors) == 1:
                print(f'ALMOST {errors[0]}')
            else:
                print('INCORRECT')


if __name__ == '__main__':
    solve()
